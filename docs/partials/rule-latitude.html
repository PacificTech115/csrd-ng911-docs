<!-- PAGE HEADER -->
<header class="page-header">
  <div class="page-header-content">
    <div class="breadcrumb">
      <a href="#Documentation">Home</a>
      <span class="sep"><i class="fas fa-chevron-right"></i></span>
      <a href="#attribute-rules">Attribute Rules</a>
      <span class="sep"><i class="fas fa-chevron-right"></i></span>
      <span class="current">4. Latitude</span>
    </div>
    <div class="detail-banner">
      <div class="banner-icon" style="background:var(--green)">
        <i class="fas fa-location-crosshairs"></i>
      </div>
      <div class="banner-info">
        <h1>4. Latitude</h1>
        <div class="banner-tags">
          <span class="banner-tag"><i class="fas fa-bullseye"></i>&nbsp; Target: Lat</span>
          <span class="banner-tag"><i class="fas fa-bolt"></i>&nbsp; Triggers: Insert / Update</span>
          <span class="banner-tag"><i class="fas fa-calculator"></i>&nbsp; Type: Calculation</span>
        </div>
      </div>
    </div>
  </div>
</header>

<div class="content-wrap">

<!-- DESCRIPTION -->
<section>
  <h2 class="reveal">Description</h2>
  <p class="reveal">Extracts the Y coordinate (latitude) from feature geometry. Uses identical logic to the Longitude rule, including Web Mercator conversion, but returns the latitude component (<code>ll[0]</code>) instead of longitude (<code>ll[1]</code>). The current source file contains the same code as Longitude &mdash; during deployment, the return values should reference <code>ll[0]</code> for latitude and <code>g.y</code> for the direct-degree path.</p>
</section>

<!-- METADATA -->
<section>
  <h2 class="reveal">Metadata</h2>
  <div class="card reveal">
    <table>
      <thead><tr><th>Property</th><th>Value</th></tr></thead>
      <tbody>
        <tr><td>Target Field</td><td><code>Lat</code></td></tr>
        <tr><td>Triggers</td><td>Insert, Update</td></tr>
        <tr><td>Input</td><td>Feature Geometry (Y coordinate)</td></tr>
        <tr><td>Precision</td><td>6 decimal places</td></tr>
        <tr><td>Relationship</td><td>Mirror of Longitude rule (returns Y instead of X)</td></tr>
      </tbody>
    </table>
  </div>
</section>

<!-- FULL SOURCE CODE -->
<section>
  <h2 class="reveal">Full Source Code</h2>

  <div class="alert warning reveal">
    <i class="fas fa-exclamation-triangle"></i>
    <span><strong>Deployment Note:</strong> The deployed rule should return <code>Round(ll[0], 6)</code> for the Web Mercator path and <code>Round(g.y, 6)</code> for the direct-degree path. The source below currently mirrors the Longitude file &mdash; verify return indices before publishing.</span>
  </div>

  <div class="reveal">
    <div class="code-block">
      <div class="code-header">
        <span class="lang-tag">Arcade</span>
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
      </div>
<pre><span class="code-section" data-section="1"><span class="kw">var</span> g = <span class="fn">Geometry</span>(<span class="var">$feature</span>);
<span class="kw">if</span> (<span class="fn">IsEmpty</span>(g)) <span class="kw">return</span> <span class="bi">Null</span>;

<span class="kw">if</span> (<span class="fn">TypeOf</span>(g) != <span class="str">"Point"</span>) g = <span class="fn">Centroid</span>(g);</span>

<span class="code-section" data-section="2"><span class="kw">var</span> sr = g.spatialReference;
<span class="kw">var</span> wkid = <span class="fn">DefaultValue</span>(sr.wkid, <span class="fn">DefaultValue</span>(sr.latestWkid, <span class="num">-1</span>));</span>

<span class="code-section" data-section="3"><span class="kw">function</span> <span class="fn">WebMercatorToLatLon</span>(x, y) {
  <span class="kw">var</span> originShift = <span class="num">2.0</span> * PI * <span class="num">6378137.0</span> / <span class="num">2.0</span>;
  <span class="kw">var</span> lon = (x / originShift) * <span class="num">180.0</span>;
  <span class="kw">var</span> lat = (y / originShift) * <span class="num">180.0</span>;
  lat = <span class="num">180.0</span> / PI * (<span class="num">2.0</span> * <span class="fn">Atan</span>(<span class="fn">Exp</span>(lat * PI / <span class="num">180.0</span>)) - PI / <span class="num">2.0</span>);
  <span class="kw">return</span> [lat, lon];
}

<span class="kw">var</span> x = g.x;
<span class="kw">var</span> y = g.y;

<span class="cm">// Web Mercator stored coords → convert</span>
<span class="kw">if</span> (wkid == <span class="num">3857</span> || wkid == <span class="num">102100</span> || wkid == <span class="num">102113</span>) {
  <span class="kw">var</span> ll = <span class="fn">WebMercatorToLatLon</span>(x, y);
  <span class="kw">return</span> <span class="fn">Round</span>(ll[<span class="num">1</span>], <span class="num">6</span>); <span class="cm">// ⚠ Should be ll[0] for latitude</span>
}</span>

<span class="code-section" data-section="4"><span class="cm">// Already looks like degrees → use directly</span>
<span class="kw">if</span> (<span class="fn">Abs</span>(x) &lt;= <span class="num">180</span> &amp;&amp; <span class="fn">Abs</span>(y) &lt;= <span class="num">90</span>) {
  <span class="kw">return</span> <span class="fn">Round</span>(x, <span class="num">6</span>); <span class="cm">// ⚠ Should be Round(g.y, 6) for latitude</span>
}

<span class="cm">// Other projected CRS (UTM/state plane/etc) → cannot reliably convert here</span>
<span class="kw">return</span> <span class="bi">Null</span>;</span></pre>
    </div>
    <div class="section-popup" id="sectionPopup"></div>
    </div>
  </details>
</section>

<!-- SECTION-BY-SECTION BREAKDOWN -->
<section>
  <h2 class="reveal">Section-by-Section Breakdown</h2>

  <div class="alert info reveal">
    <i class="fas fa-info-circle"></i>
    <span>This rule mirrors the Longitude rule. Any changes to the Web Mercator conversion function should be applied to both rules simultaneously.</span>
  </div>

  <div class="breakdown-card reveal" data-section="1">
    <h4>1. Geometry Extraction</h4>
    <div class="breakdown-meta">
      <span class="meta-tag">Lines 1 &ndash; 4</span>
      <span class="meta-tag">Input: Geometry</span>
      <span class="meta-tag">Output: Point or Null</span>
    </div>
    <p>Identical to Longitude rule. Gets geometry; returns Null if empty; uses <code>Centroid(g)</code> for non-points.</p>
    <div class="breakdown-detail">
      <strong>Keep in sync</strong>
      <ul>
        <li>Any change to Longitude rule section 1 must be applied here.</li>
      </ul>
    </div>
  </div>

  <div class="breakdown-card reveal reveal-delay-1" data-section="2">
    <h4>2. Spatial Reference Detection</h4>
    <div class="breakdown-meta">
      <span class="meta-tag">Lines 6 &ndash; 7</span>
      <span class="meta-tag">Input: g.spatialReference</span>
    </div>
    <p>Identical to Longitude rule. Reads wkid with latestWkid fallback.</p>
    <div class="breakdown-detail">
      <strong>Keep in sync</strong>
      <ul>
        <li>Match Longitude rule section 2.</li>
      </ul>
    </div>
  </div>

  <div class="breakdown-card reveal" data-section="3">
    <h4>3. Web Mercator Conversion</h4>
    <div class="breakdown-meta">
      <span class="meta-tag">Lines 9 &ndash; 24</span>
      <span class="meta-tag">Input: g.x, g.y (meters)</span>
      <span class="meta-tag">Output: latitude (degrees)</span>
    </div>
    <p>Same <code>WebMercatorToLatLon</code> as Longitude. <strong>Critical:</strong> returns <code>ll[0]</code> (latitude), not <code>ll[1]</code> (longitude). The function returns <code>[lat, lon]</code>.</p>
    <div class="breakdown-detail">
      <strong>Logic</strong>
      <ul>
        <li>If wkid in {3857, 102100, 102113}: return <code>Round(ll[0], 6)</code> (latitude)</li>
      </ul>
      <strong>To replicate</strong>
      <ul>
        <li>Copy from Longitude rule but change <code>ll[1]</code> to <code>ll[0]</code>. Any CRS/conversion change must be applied to both rules.</li>
      </ul>
    </div>
  </div>

  <div class="breakdown-card reveal reveal-delay-1" data-section="4">
    <h4>4. Direct Degree Handling and Fallback</h4>
    <div class="breakdown-meta">
      <span class="meta-tag">Lines 26 &ndash; 32</span>
      <span class="meta-tag">Input: x, y</span>
      <span class="meta-tag">Output: number or Null</span>
    </div>
    <p>For degree-like coords (<code>|x| ≤ 180</code>, <code>|y| ≤ 90</code>), returns <code>Round(y, 6)</code>—latitude is the Y component in decimal degrees. For other CRS, returns Null.</p>
    <div class="breakdown-detail">
      <strong>Logic</strong>
      <ul>
        <li>If degree-like: return <code>Round(y, 6)</code> (not x—Longitude returns x)</li>
        <li>Else: return Null</li>
      </ul>
      <strong>To modify</strong>
      <ul>
        <li>Add UTM/other CRS: add conversion branch; apply same change to Longitude rule.</li>
      </ul>
    </div>
  </div>

</section>

</div><!-- /content-wrap -->

<!-- FOOTER -->